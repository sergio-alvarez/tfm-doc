<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.0.preview.7">
<meta name="author" content="Sergio Álvarez Suárez">
<title>Geolocalización de usuarios en medios sociales mediante análisis de contenidos</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden], template { display: none; }
script { display: none !important; }
html { font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a { background: transparent; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }
meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }
meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
.keyseq kbd:first-child { margin-left: 0; }
.keyseq kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }
b.button:before { content: "["; padding: 0 3px 0 2px; }
b.button:after { content: "]"; padding: 0 2px 0 3px; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 768px) { body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: .90em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .mathblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock pre:not([class]), .listingblock pre:not([class]) { background: none; }
.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock pre > code, .literalblock pre[class] > code, .listingblock pre > code, .listingblock pre[class] > code { display: block; }
@media only screen { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }
.listingblock pre.highlight { padding: 0; }
.listingblock pre.highlight > code { padding: 0.75em 0.75em 0.5em 0.75em; }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.sass:before { content: "sass"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
tbody tr th { display: table-cell; line-height: 1.6; background: whitesmoke; }
tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
#toc.toc2 { background: white; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }
</style>
</head>
<body class="article">
<div id="header">
<h1>Geolocalización de usuarios en medios sociales mediante análisis de contenidos</h1>
<span id="author" class="author">Sergio Álvarez Suárez</span><br>
<div id="toc" class="toc">
<div id="toctitle">Tabla de Contenidos</div>
<ul class="sectlevel1">
<li><a href="#_introducción">1. Introducción</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_motivación_del_proyecto">1.1. Motivación del proyecto</a></li>
<li><a href="#_alcance">1.2. Alcance</a></li>
<li><a href="#_estado_del_arte">1.3. Estado del arte</a></li>
</ul>
</li>
<li><a href="#_algoritmos_y_aspectos_teóricos">2. Algoritmos y aspectos teóricos</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_log_likelihood_ratio_test">2.1. Log Likelihood-Ratio test</a></li>
<li><a href="#_términos_discriminativos">2.2. Términos discriminativos</a></li>
<li><a href="#_pseudocódigo_para_ilustrar_el_proceso_completo_de_análisis_de_tuits">2.3. Pseudocódigo para ilustrar el proceso completo de análisis de tuits</a></li>
</ul>
</li>
<li><a href="#_experimentos_y_resultados">3. Experimentos y resultados</a></li>
<li><a href="#_conclusiones_del_sistema_de_geolocalización">4. Conclusiones del sistema de geolocalización</a></li>
<li><a href="#_aplicación_web_de_geolocalización_como_servicio">5. Aplicación web de geolocalización como servicio</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_análisis_del_sistema">5.1. Análisis del sistema</a></li>
</ul>
</li>
<li><a href="#_scala">Appendix A: Scala</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_sbt">sbt</a></li>
</ul>
</li>
<li><a href="#_software_de_aprendizaje_automático_y_vowpal_wabbit">Appendix B: Software de aprendizaje automático y Vowpal Wabbit</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_software_de_aprendizaje_automático">Software de aprendizaje automático</a></li>
<li><a href="#_vowpal_wabbit">Vowpal Wabbit</a></li>
</ul>
</li>
<li><a href="#_falcon_sistema_para_coleccionar_datos_de_la_api_streaming_de_twitter">Appendix C: Falcon, sistema para coleccionar datos de la API Streaming de Twitter</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_almacenamiento_de_datos">Almacenamiento de datos</a></li>
<li><a href="#_parámetros_del_sistema">Parámetros del sistema</a></li>
<li><a href="#_ejemplo_de_resultados">Ejemplo de resultados</a></li>
</ul>
</li>
<li><a href="#_b2pick_aplicación_web_para_seleccionar_em_bounding_boxes_em">Appendix D: B2pick, aplicación web para seleccionar <em>bounding boxes</em></a></li>
<li><a href="#_tweetheat_mapa_de_calor_sobre_ficheros_tsv_de_puntuación">Appendix E: TweetHeat, mapa de calor sobre ficheros TSV de puntuación</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introducción">1. Introducción</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_motivación_del_proyecto">1.1. Motivación del proyecto</h3>
<div class="paragraph">
<p>Aquí la motivación del proyecto</p>
</div>
</div>
<div class="sect2">
<h3 id="_alcance">1.2. Alcance</h3>
<div class="paragraph">
<p>Aquí el alcance del proyecto.</p>
</div>
</div>
<div class="sect2">
<h3 id="_estado_del_arte">1.3. Estado del arte</h3>
<div class="paragraph">
<p>El crecimiento exponencial de las redes sociales durante los últimos años ha despertado un gran interés en los diferentes ámbitos de la informática, siendo un claro objetivo comercial para profesionales del sector, así como un nuevo campo de investigación para los investigadores universitarios.</p>
</div>
<div class="paragraph">
<p>Como consecuencia de todo ello, durante los últimos años han ido apareciendo diversas aplicaciones que, de una u otra manera, se centran en estudiar ciertos aspectos de las redes sociales para poder extraer información acerca de sus usuarios gracias a las diversas publicaciones que estos mismos realizan en sus perfiles.</p>
</div>
<div class="paragraph">
<p>El estudio de la geolocalización de un usuario a partir de su contenido, sin embargo, es una de las pocas áreas que <em>tan sólo</em> agrupa un pequeño número de estudios teóricos, pero en donde no han proliferado herramientas que comprueben de manera empírica los resultados teóricos emitidos por diversos investigadores.</p>
</div>
<div class="paragraph">
<p>Por ello, en este capítulo se recopilan algunos estudios teóricos y artículos de investigación que han servido como punto de arranque para este proyecto.</p>
</div>
<div class="sect3">
<h4 id="_estudios_y_artículos_de_investigación">1.3.1. Estudios y artículos de investigación</h4>
<div class="paragraph">
<p>Se pueden encontrar varias tendencias en la investigación de la geolocalización de los tuits y usarios de Twitter. Por un lado, existen investigadores que basan sus estudios en encontrar términos o entidades con significado geográfico propio, que se puedan cotejar con un gazetteer<span class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span> con el objetivo de poder identificar nombres de lugares o coordenadas geográficas, intuyendo que aquellas que más veces aparezcan en el <em>timeline</em> del usuario son aquellas más próximas a su localización real.</p>
</div>
<div class="paragraph">
<p>Por otro lado, grupos de investigadores han optado por estudiar únicamente el contenido de un tuit con el objetivo de encontrar aquellas palabras más características de un lugar y que puedan ser lo suficientemente discriminativas. En estos casos, se suele tender a buscar aquellos términos con una alta frecuencia y una baja dispersión geográfica.</p>
</div>
<div class="paragraph">
<p>Existen también enfoques donde se ha optado por una estrategia basada en estudiar el comportamiento de un usuario, utilizando técnicas de los dos métodos anteriores y combinándola con la información obtenida a través de servicios de terceros que puedan realizar publicaciones en el <em>timeline</em> del usuario y además adjuntar información geolocalizada (<strong>Foursquare</strong> sería un claro ejemplo de este tipo de servicios).</p>
</div>
<div class="sect4">
<h5 id="_tweets_from_justin_bieber_s_heart_the_dynamics_of_the_location_field_in_user_profiles">Tweets from Justin Bieber’s Heart: The Dynamics of the "Location" Field in User Profiles</h5>
<div class="paragraph">
<p><em>Por Brent Hecht et al. Northwestern University y Palo Alto Research Center</em></p>
</div>
<div class="paragraph">
<p>El estudio liderado por Brent Hecht demuestra de manera científica como el uso del campo de Localización disponible en los perfiles de los usuarios en Twitter no es un indicador válido para obtener su posición geográfica real.</p>
</div>
<div class="paragraph">
<p>Entre los datos obtenidos por Brent y su equipo se pueden destacar los siguientes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Sólo un 66% de los usuarios utiliza el campo de Localización para aportar información geográfica válida (es decir, localizaciones reales pero que <strong>no tienen porqué indicar su situación real</strong>. Por ejemplo, si una persona de <strong>Oviedo</strong> escribe <strong>California</strong> en el campo de Localización de su perfil, este estudio lo incluye dentro del 66% anterior).</p>
</li>
<li>
<p>Algunos de los usos que los usuarios dentro del 34% restante aplican al campo de Localización se puede observar en <a href="#location-use-type">Tipos de uso del campo de Localización por parte de los usuarios de Twitter</a>.</p>
</li>
<li>
<p>La manera de distinguir entre localización real y ficticia supuso de un proceso manual en el que dos miembros del equipo debieron revisar tuit a tuit el campo de Localización, debido a la habilidad de los usuarios para poder expresar sarcasmo o ironía, así como expresiones comunes que pueden tener asociado un componente geográfico inherente (un ejemplo puede ser referirse al Principado de Asturias como <em>la tierrina</em>).</p>
</li>
</ol>
</div>
<table id="location-use-type" class="tableblock frame-all grid-all" style="width: 100%;">
<caption class="title">Table 1. Tipos de uso del campo de Localización por parte de los usuarios de Twitter</caption>
<colgroup>
<col style="width: 75%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cultura popular</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12.9%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Referencias a su propia privacidad</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.2%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Insultos o contenido violento</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.6%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Localizaciones no terráqueas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5.0%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Emociones negativas hacia su localización real</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.2%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Naturaleza sexual</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.2%</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Como alternativa a los resultados anteriores, y buscando una manera de automatizar el proceso y encontrar resultados más fiables y exhaustivos, se propusieron hacer un primer experimento para comprobar si el estudio de los contenidos publicados por un usuario pueden aportar la información necesaria para permitir inferir su ubicación geográfica.</p>
</div>
<div class="paragraph">
<p>Para ello, utilizaron un software de aprendizaje automático y un clasificador Bayesiano multinomial que en base a un conjunto de datos obtenidos a partir de aplicar el algoritmo <em>CALGARI</em> (de implementación propia), fuese capaz de predecir a qué área (País y Estado) pertenece un tuit en base a su contenido.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">CALGARI</div>
<div class="paragraph">
<p>El algoritmo CALGARI tiene como objetivo normalizar la frecuencia con la que un término ha aparecido dentro de un dataset de tuits para priorizar aquellos que son más específicas de un área (ciudad o estado) en concreto, penalizando palabras comunes como <em>ya, hola, adiós, etc.</em></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Entre los resultados ofrecidos por el estudio destacan un <strong>72.7% de acierto para inferir el país</strong> de un usuario pero tan <strong>sólo un 30% de acierto a nivel de estado</strong>.</p>
</div>
<div class="paragraph">
<p>Como apunte adicional, es interesante una afirmación que se enuncia en el artículo cuando se hace referencia al nuevo campo de localización que la API Streaming de Twitter ofrece para adjuntar información geolocalizada (siempre que el usuario lo permita):</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>First, our focus is on the geographic information revealed in the “location” field of user profiles, a type of geographic information that is prevalent across the Web 2.0 world. <strong>Second, we found that only 0.77% of our 62 million tweets contained this embedded location information</strong>.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>De 62 millones de tuits, únicamente un 0.77% (~= 477.400) contenían información geográfica adjunta.</p>
</div>
</div>
<div class="sect4">
<h5 id="_where_is_this_tweet_from_inferring_home_locations_of_twitter_users">Where Is This Tweet From? Inferring Home Locations of Twitter Users</h5>
<div class="paragraph">
<p><em>Por Jalal Mahmud et al. IBM Research</em></p>
</div>
<div class="paragraph">
<p>Con el objetivo de poder identificar un tuit a diferentes granularidades: ciudad o estado, el estudio plantea la posibilidad de analizar tres tipos de términos diferentes para localizar una publicación en Twitter:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Palabras</strong></p>
</li>
<li>
<p><strong>Hashtags</strong></p>
</li>
<li>
<p><strong>Nombres de lugares</strong> (utilizando un gazetteer geográfico). Puesto que estos términos podía estar compuestos por más de una palabra, se utilizaron bigramas y trigamas, así como un heurístico especializado en reconocer nombres de lugares expresados mediante vocabulario común (un ejemplo sería <em>Red Sox</em> para referirse a la ciudad de Boston).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Es interesante observar como empiezan a aparecer pequeñas diferencias entre términos, considerando que en función de su categoría, pueden ofrecer más o menos información geográfica. Esta misma estrategia será también utilizada en el presente proyecto, mediante la extracción de Hashtags, Menciones y N-gramas.</p>
</div>
<div class="paragraph">
<p>Con el objetivo de minimizar la aparición de ruido, normalizaron el contenido de cada tuit eliminando signos de puntuación (a excepción de aquellos que indican una entidad propia cuando se encuentran al principio de una palabra, como <code>#</code> para indicar <em>hashtags</em>) y palabras vacías.</p>
</div>
<div class="paragraph">
<p>También se hace mención a la utilización de un <strong>software de aprendizaje automático</strong>, en este caso WEKA, y su conjunción con un modelo estadístico que realice los cálculos necesarios para el clasificador. El modelo que seleccionaron de manera empírica fue un clasificador Bayesiano multinomial.</p>
</div>
<div class="paragraph">
<p>La estrategia propuesta en este trabajo para inferir la localización de un usuario en Twitter fue:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A lo largo de sus tuits, mencionará más veces su ciudad o estado de origen que el resto de ciudades o estados.</p>
</li>
<li>
<p>Visitará más lugares de su ciudad o estado de origen que del resto de ciudades o estados (para detectar este tipo de visitas, se guardan todas las URLs generadas a partir de <em>check-ins</em> compartidos a través de <strong>Foursquare</strong> para luego comprobar su información asociada a través de la propia API de Foursquare).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A partir de estas premisas y de las decisiones anteriores, se crearon 3 modelos diferentes para poder entrenar sobre cada uno de los términos que se quieren extraer: palabras, hashtags y nombres de lugares. Los resultados presentados a nivel de ciudad no fueron realmente positivos, y sólo presentan niveles de precisión superiores al 70% cuando se permiten márgenes de error superiores a 200 millas (~= 322 kilómetros).</p>
</div>
<div class="paragraph">
<p>Por último, no se especifica con exactitud cómo actúa realmente el algoritmo cuando se trabaja con usuarios que no tienen contenido generado por Foursquare o no hacen una referencia explícita a su ciudad, estado o país.</p>
</div>
</div>
<div class="sect4">
<h5 id="_tweolocator_a_non_intrusive_geographical_locator_system_for_twitter">TweoLocator: A Non-Intrusive Geographical Locator System for Twitter</h5>
<div class="paragraph">
<p><em>Por Yi-Shin Chen et al. National Tsing Hua University</em></p>
</div>
<div class="paragraph">
<p>En este estudio, Yi-Shin Chen diseña un sistema que a través de diferentes etapas y aglutinando varios procesos es capaz de inferir la localización de un usuario en Twitter en función del contenido de sus tuits.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Baseline Classification</dt>
<dd>
<p>A partir de un gran dataset de usuarios de Twitter, en esta fase se realiza un análisis para comprobar qué perfiles puede ser potencialmente válidos para realizar un análisis de contenidos, eliminando aquellos que puedan pertenecer a <em>bots</em> automáticos o sean perfiles de spam. Una vez se obtiene una masa de usuarios válidos se procede, dentro aún de esta etapa, a analizar todos sus tuits (a excepción de aquellos con información de geolocalización asociada) para volver a categorizarlos en 3 tipos:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Direct subject</strong>: Tuits que hacen referencia al usuario en primera persona.</p>
</li>
<li>
<p><strong>Anonymous subject</strong>: Tuits que no hacen una referencia directa al usuario, pero utilizan otros pronombres personales o la primera secuencia de palabras es un verbo que no es una palabra vacía.</p>
</li>
<li>
<p><strong>Others</strong>: Tuits descartados por no pertenecer a ninguna de las 2 categorías anteriores.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Rule Generation</dt>
<dd>
<p>Una vez todos los tuits anteriores han sido analizados semánticamente se realiza una normalización de los mismos aplicando técnicas de análisis de texto (utilizando un tokenizador y un stemmer) para luego poder formar n-gramas como los mismos. Durante esta etapa, se intentan inferir reglas que permitan asociar términos comunes a localizaciones específicas como aeropuertos, parques, estaciones de tren, etc.</p>
</dd>
<dt class="hdlist1">Location Discovery</dt>
<dd>
<p>A partir de los términos de cada tuit, se generan trigramas, bigramas y unigramas y se comparan sobre un gazetteer y las reglas generadas en el paso anterior, obteniendo localizaciones que se pueden agrupar en:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Explicit Specific</strong>: Nombres que hacen una referencia directa a una ciudad o lugar determinado, como por ejemplo «The White House» or «Los Angeles».</p>
</li>
<li>
<p><strong>Explicit</strong>: Nombres que hacen referencia a localizaciones generales como parques o gimnasios.</p>
</li>
<li>
<p><strong>Implicit</strong>: Combinaciones de palabras que implícitamente sugieren una localización. Estos resultaos se obtienen a partir de las reglas generadas en el paso anterior.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Toponym Removal</dt>
<dd>
<p>Mediante la utilización de un clúster, y partiendo de la premisa de que un usuario nombrará con mayor frecuencia lugares cercanos a su lugar de origen, en esta fase se analizan las menciones realizadas por el usuario sobre ciudades, lugares, países y se refinarán los datos para obtener su lugar de origen.</p>
</dd>
<dt class="hdlist1">Timeline Sorting</dt>
<dd>
<p>Es el último paso en el refinamiento de los datos. En esta fase se intenta minimizar la aparición de ruido detectando aquellas ocasiones en las que el usuario hace referencia a una localización geográfica sin aportar una información real acerca de su posición. Por ejemplo, es habitual que alguien situado en Asturias pueda nombrar la ciudad de Nueva York para hablar de alguna noticia o para mostrar sus ganas por conocer la ciudad, sin que esa mención indique que se encuentre realmente allí. Para resolver este problema, y aceptando que en algunos casos sólo se podrían resolver dichas inconsistencias de manera manual mediante la intervención humana, se diseñó un sistema que a partir de dos tuits con contenido geolocalizado consecutivos (del mismo usuario) compruebe si su diferencia en el tiempo es acorde a la posibilidad de haberse movido entre ambos puntos a una velocidad normal de transporte.</p>
</dd>
<dt class="hdlist1">Location Inferred</dt>
<dd>
<p>De acuerdo a los resultados obtenidos en todas las fases anteriores y de acuerdo al nivel sobre que el que se haya podido inferir su localización, los usuarios son clasificados en los siguientes grupos:</p>
<div class="ulist">
<ul>
<li>
<p><strong>No information</strong>: Si no se ha podido obtener información geográfica válida para inferir la localización del usuario.</p>
</li>
<li>
<p><strong>Just country</strong>: Si sólo se ha podido inferir el país del usuario.</p>
</li>
<li>
<p><strong>Timeline</strong>: Se han podido detectar ubicaciones actuales y previas del usuario, pero no su lugar de origen.</p>
</li>
<li>
<p><strong>Hometown</strong>: Se han podido detectar ubincaciones actuales y previas del usuario y <strong>también</strong> su lugar de origen. Es el grupo con información más completa.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>En las conclusiones que se exponen en el artículo se muestran unos resultados bastante aceptables, donde hay porcentajes de acierto cercanos al 80%. Al igual que en el caso anterior, TweoLocator tiene una gran dependencia de que los usuarios incluyan en el contenido de sus tuits información explícitamente geolocalizable.</p>
</div>
</div>
<div class="sect4">
<h5 id="_a_multi_indicator_approach_for_geolocalization_of_tweets">A Multi-Indicator Approach for Geolocalization of Tweets</h5>
<div class="paragraph">
<p><em>Por Axel Schulz et al. SAP Research</em></p>
</div>
<div class="paragraph">
<p>En este artículo, un equipo de investigación de <strong>SAP AG</strong> presenta un enfoque muy interesante para inferir la localización de un usuario mediante la utilización de formas poligonales en 3D. Los polígonos se superponen, y la intersección de mayor altura es el área con más probabilidades de contener al usuario analizado.</p>
</div>
<div class="paragraph">
<p>La altura de cada polígono viene determinada por pesos específicos que se aplican en función de la fuente utilizada para obtener esa localización. Cada fuente tiene sus propios estándares de calidad y sus propias métricas para indicar más o menos fiabilidad.</p>
</div>
<div class="paragraph">
<p>Para obtener las coordenadas o posiciones geográficas que deben ocupar los polígonos, los investigadores extraen información de los siguientes campos:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Contenido del tuit</dt>
<dd>
<p>Se optó por utilizar <strong>DBPedia Spotlight</strong> para extraer las entidades que existían en el tuit. Con los resultados de la extracción, se seleccionaban únicamente aquellas que tenían coordenadas asociadas. Además, se utilizó como calidad de cada predicción la propia confianza aportada por DBPedia Spotlight en su resultado. También se utilizaron las publicaciones realizadas a través de servicios como Foursquare, Flickr o Ubisoft, las cuales tienen adjunta información geográfica precisa mediante la utilización de coordenadas geográficas.</p>
</dd>
<dt class="hdlist1">Localización</dt>
<dd>
<p>Se hizo uso de gazetteers que permitiesen buscar coincidencias textuales en el campo de Localización. Además, se volvió a utilizar DBPedia Spotlight para conseguir trabajar con expresiones comunes como «La gran manzana» y expresiones regulares para detectar si algún usuario incluía coordenadas geográficas directamente en su campo de Localización.</p>
</dd>
<dt class="hdlist1">Web del usuario</dt>
<dd>
<p>Para aquellos usuarios que añaden en su perfil su página web personal se aplican dos estrategias:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Extraer el dominio de la página (.com, .es, etc).</p>
</li>
<li>
<p>Utilizar la dirección IP y obtener las coordenadas a través del servicio IPInfoDB.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Zona horaria</dt>
<dd>
<p>Se asume como cierto que la zona horaria asociada al usuario es la capital de su país de origen.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Los resultados de este estudio presentan mejorías respecto a otras investigaciones basadas en inferir la localidad de un usuario mediante el uso de <strong>múltiples indicadores</strong> con un 37% de acierto con una distancia de error de 10km y un 48% para 25km; así como un 54% cuando el margen se amplía a 50km.</p>
</div>
</div>
<div class="sect4">
<h5 id="_inferring_the_origin_locations_of_tweets_with_quantitative_confidence">Inferring the Origin Locations of Tweets with Quantitative Confidence</h5>
<div class="paragraph">
<p><em>Por Reid Priedhorsky et al. Los Alamos National Laboratory y Northeastern Illinois University</em></p>
</div>
<div class="paragraph">
<p>El artículo parte de la premisa de que no es posible obtener la localización de un tuit con una exactitud total, si no que lo más acertado es ofrecer un modelo probabilístico que muestre las diferentes localizaciones a las que un tuit puede pertenecer asociadas a un grado de confianza (probabilidad).</p>
</div>
<div class="paragraph">
<p>Para obtener un dataset de entrenamiento, se utilizó la API Streaming de Twitter para después realizar un procesamiento de cada tuit extrayendo información de los campos: descripción del usuario, idioma del perfil seleccionado, campo de localización, zona horaria y contenido del tuit. Sobre esta información, se extrajeron bigramas para todos los términos adyacentes (a excepción del campo de zona horaria). Además, también se almacenó la información geográfica adjunta al tuit para poder realizar los experimentos y el entrenamiento del modelo.</p>
</div>
<div class="paragraph">
<p>Un ejemplo de la extracción de bigramas sería:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Obviamente todo esto se hace para acabar con la costumbre de nuestra infancia de los álbumes de cromos.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Que se traduciría a:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Obviamente todo, todo esto, esto se, se hace, hace para, para acabar, acabar con, con la, la costumbre, costumbre de, de nuestra, nuestra infancia, infancia de, de los, los álbumes, álbumes de, de cromos.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Una vez con toda esta información almacenada, se utilizó una técnica de estimación denominada «gaussian mixture models» en donde cada bigrama que aparezca más de un mínimo número de veces se asocia a las coordenadas del tuit que lo contiene. Cada asociación, va vinculada a un peso específico en función del bigrama y la suma de todos los pesos asociados a un tuit es su probabilidad total de pertenecer a esas coordenadas.</p>
</div>
<div class="paragraph">
<p>Para calcular el peso que se le debe dar a cada a cada bigrama, el equipo de Reid Priedhorsky desarrolló tres métodos diferentes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Peso por propiedades de calidad</p>
</li>
<li>
<p>Peso por error inverso</p>
</li>
<li>
<p>Peso por optimización</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Todos ellos con una alta dosis de componente algorítmico y matemático.</p>
</div>
<div class="paragraph">
<p>Los resultados del estudio revelaron un acierto del 83% para aquellos tuits que contenían bigramas con contenido explícitamente localizable (nombres de lugares) frente a un 57% de acierto sobre tuits sin información geográfica.</p>
</div>
</div>
<div class="sect4">
<h5 id="_you_are_where_you_tweet_a_content_based_approach_to_geo_locating_twitter_users">You Are Where You Tweet: A Content-Based Approach to Geo-locating Twitter Users</h5>
<div class="paragraph">
<p><em>Por Zhiyuan Cheng et al. Texas A&amp;M University</em></p>
</div>
<div class="paragraph">
<p>En este estudio, Zhiyuan Cheng y su equipo aportan datos interesantes en la investigación de la geolocalización en Twitter. Centrados en buscar un algoritmo capaz de inferir la localización de un usuario <strong>únicamente</strong> con el contenido de sus tuits, establecen tres criterios que serán ampliamente utilizados por el resto de investigaciones posteriores:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se deben buscar términos con un fuerte componente discriminativo mediante la aplicación de algoritmos que sirvan para normalizar la frecuencia de apariciones de un término.</p>
</li>
<li>
<p>El test Likelihood ratio es capaz de obtener probabilidades bastante acertadas para este dominio específico.</p>
</li>
<li>
<p>Los términos más altamente discriminativos se caracterizan por una alta frecuencia y una baja dispersión.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Entre los resultados que presentaron, afirman ser capaces de localizar correctamente el 51% de los tuits dentro de un radio de error de 100 millas (~= 161 km.).</p>
</div>
</div>
<div class="sect4">
<h5 id="_otros_em_papers_em_de_interés">Otros <em>papers</em> de interés</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Location Type Classification Using Tweet Content</strong> <em>por Haibin Liu et al. The Pennsylvania State University</em></p>
</li>
<li>
<p><strong>TweetLocalize: Inferring Author Location in Social Media</strong> <em>por Evan Sparks et al. University of California-Berkeley</em></p>
</li>
<li>
<p><strong>Inferring the Location of Twitter Messages Based on User Relationships</strong> <em>por Clodoveu A. Davis Jr. et al. Universidade Federal de Minas Gerais</em></p>
</li>
<li>
<p><strong>Geolocation Prediction in Social Media Data by Finding Location Indicative Words</strong> <em>por HAN Bo et al. University of Melbourne</em></p>
</li>
<li>
<p><strong>Home Location Identification of Twitter Users</strong> <em>por Jalal Mahmud et al. IBM Research</em></p>
</li>
<li>
<p><strong>Geotagging One Hundred Million Twitter Accounts with Total Variation Minimization</strong> <em>por Ryan Compton et al. HRL Laboratories (Malibu)</em></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_algoritmos_y_aspectos_teóricos">2. Algoritmos y aspectos teóricos</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_log_likelihood_ratio_test">2.1. Log Likelihood-Ratio test</h3>
<div class="paragraph">
<p>El test Log Likelihood-Ratio (<a href="http://www.itl.nist.gov/div898/handbook/apr/section2/apr233.htm">http://www.itl.nist.gov/div898/handbook/apr/section2/apr233.htm</a>) es un método estadístico ampliamente utilizado en problemas donde se pretenden comparar dos conjuntos de datos a través de una serie de supuestos.</p>
</div>
<div class="paragraph">
<p>En el caso del presente proyecto, la idea principal es aplicar LLR sobre los dos conjuntos de datos que contienen, por un lado, los tuits que se han recogido para el área local sobre el que se quieren comenzar a inferir tuits, y por el otro, un conjunto de tuits localizado en un área que se podría entender como global respecto al conjunto de datos local (por lo general, las áreas globales son localizaciones donde se habla el mismo idioma que en el área local, pero abarca otros territorios).</p>
</div>
<div class="paragraph">
<p>En este caso, partimos del <strong>supuesto</strong> de que el área local es un caso especializado del área global, el cual se puede diferenciar por los términos que contiene. Sobre este supuesto, el test Log Likelihood-Ratio nos devolverá un valor con la probabilidad de que cada término del área local sea realmente discriminativo comparando su frecuencia también en el conjunto de datos globales. Cuanto más discriminativo sea el término, mayor será su valor LLR. Sin embargo, todos aquellos que no sirvan para diferenciar al conjunto de datos especializado, tendrán un valor negativo.</p>
</div>
<div class="paragraph">
<p>El valor LLR de cada término se utilizará para calcular la probabilidad de que los nuevos tuits pertenezcan o no al área local mediante un sumatorio de todos los valores para cada término que forma el tuit.</p>
</div>
<div class="paragraph">
<p>La consideración acerca de qué es un <strong>término</strong> se explica en <a href="#_términos_discriminativos">Términos discriminativos</a>, pero se podría definir resumidamente como todo aquel lexema que pueda contener información geolocalizable asociada.</p>
</div>
<div class="sect3">
<h4 id="_log_likelihood_ratio_test_normalizado">2.1.1. Log Likelihood-Ratio test normalizado</h4>
<div class="paragraph">
<p>La implementación del algoritmo Log Likelihood-Ratio utilizado se basa en la interpretación propuesta en el artículo: Java, Akshay, et al. «Why we twitter: understanding microblogging usage and communities». Perteneciente a la novena WebKDD y primer taller SNA-KDD 2007 en minería de datos web y análisis de redes sociales.<span class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</span></p>
</div>
<div class="paragraph">
<p>Tras los primeros experimentos, aunque se vislumbraron resultados esperanzadores, se observó también como algunos términos que se sabía eran discruminativos, no obtenían una puntuación LLR lo suficientemente alta como para que el sistema los pudiese considerar discriminativos en el futuro. Por tanto, se realizó una nueva implementación <em>normalizada</em> sobre el algoritmo anterior, basada en la siguiente sospecha:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Términos como «españa», los cuales son muy representativos de tuits españoles, también son relativamente comunes en tuits chilenos, y por tanto no se puede interpretar que vayan a tener la misma importancia para discrimar entre ambos, por mucho que su uso sea mayor en España. Sin embargo, términos como «culín sidra», los cuales no tienen una gran representatividad en tuits españoles y es casi seguro que no tengan ninguna aparición en tuits procedentes de Chile, tienen un gran componente geográfico implícito que hace pensar que tuits que contenga ese término es <strong>muy posible</strong> que provengan de España.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Para tratar de demostrar la intuición anterior, se desarrolló una normalización basada en tres pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La puntuación LLR de cada término, es normalizada contra el mínimo (negativo) y máximo (positivo) valor teórico que LLR puede alcanzar dados dos datasets.</p>
</li>
<li>
<p>La frecuencia del término en el dataset local y global, es normalizada frente al total de frecuencias en ambos datasets.</p>
</li>
<li>
<p>Por último, el valor LLR normalizado es dividido por el valor correspondiente de la frecuencia local o global dependiendo de si el valor obtenido es positivo o negativo (es decir, si es más posible que pertenezca al dataset A o al dataset B).</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Algoritmo para normalizar el valor LLR de un término</div>
<div class="content">
<pre class="highlight"><code class="java language-java">  /*
   * @param a  frequency of token of interest in dataset A
   * @param b  frequency of token of interest in dataset B
   * @param c  total number of observations in dataset A
   * @param d  total number of observations in dataset B
   */
  public double normalizedLLR (long a, long b, long c, long d) {
    double min, max, a_norm, b_norm, llr;
    min    = getLLR(0, d, c, d);
    max    = getLLR(c, 0, c, d);
    a_norm = a / (double)c;
    b_norm = b / (double)d;
    llr    = getLLR(a, b, c, d);

    return (llr&gt;0) ? (llr/(max*a_norm)) : (-llr/(min*b_norm));
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>De esta manera, el valor LLR normalizado se puede usar como <em>proxy</em> para el nivel de confianza que tendremos a la hora de asignar cada término a uno u otro dataset. Por ejemplo, en el supuesto anterior, «españa» obtendría un peso relativamente bajo, mientras que si aparece «culín sidra» su peso sería muy alto. Además, para el término «chile», su peso sería negativo pero mucho menos que si aparece el término «achunchar», el cual sería mucho más discriminativo para descartar que un tuit provenga de España.</p>
</div>
<div class="paragraph">
<p>A continuación, se muestran los 10 resultados más discriminativos tras aplicar LLR y LLR normalizado sobre keywords que sirvan para diferenciar tuits de Asturias del resto de España:</p>
</div>
<div class="listingblock">
<div class="title">LLR sin normalizar</div>
<div class="content">
<pre>5.673174267765713    avilés
5.786668335161142    muches
6.55625607825904     gracies
6.9163915469140225   gijon
7.082198151712459    olmo
7.650261596901131    ye
7.8221070414197245   besin
8.673885864488826    gijón
11.355768634976933   asturias
13.541645339239054   oviedo</pre>
</div>
</div>
<div class="listingblock">
<div class="title">LLR normalizado</div>
<div class="content">
<pre>34.03033586645537    economia
34.83206427341024    escalera
35.896146032001866   moreda
40.13311132890776    héctor
40.13311132890776    celebralos
40.13311132890776    sidra
41.63987088300992    avilés
41.65857127377122    simón
45.94585510324283    presta</pre>
</div>
</div>
<div class="paragraph">
<p>Se puede observar como en el caso del LLR normalizado, se penalizan aquellos términos que podrían aparecer frecuentemente en otros tuits del territorio español: <em>oviedo</em>, <em>gijón</em> y <em>asturias</em>; mientras que se favorecen otros más específicos como <em>sidra</em>, <em>presta</em> o <em>celebralos</em> (escrito como se pronunciaría en asturiano).</p>
</div>
<div class="paragraph">
<p>La implementación de ambos algoritmos Root Log Likelihood-Ratio fue desarrollada por el doctor Daniel Gayo Avello.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_términos_discriminativos">2.2. Términos discriminativos</h3>
<div class="paragraph">
<p>Se consideran términos discriminativos aquellos que son capaces de aportar información muy geolocalizable de manera implícita. Un ejemplo son aquellas palabras muy propias de una localización en concreto, como el caso del término <em>sidra</em> o <em>carbayu</em>, que con mucha probabilidad indican un contenido que ha sido generado en Asturias.</p>
</div>
<div class="paragraph">
<p>La estrategia planteada en este proyecto está basada en descubrir este tipo de términos a través de los tuits que los usuarios publican para una determinada región (país, estado, ciudad, etc.). Para ello, la premisa básica es aceptar que los términos más discriminativos tenderán a tener un epicentro muy significativo donde su frecuencia es muy elevada, para después, no tener apenas dispersión y ser muy poco frecuentes en el resto.</p>
</div>
<div class="paragraph">
<p>Con el objetivo de poder aplicar los algoritmos anteriores, será necesario trabajar siempre con dos datasets sobre los que establecer la comparativa. Por un lado, se trabajará con un conjunto de datos localizados en el área en concreto que se quiera analizar, y por otro lado, otro conjunto de datos que se establezcan en un área más global para ese mismo idioma.</p>
</div>
<div class="paragraph">
<p>A partir de ahí, el análisis de cada dataset extraerá los siguientes términos:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Menciones</dt>
<dd>
<p>Se considerán menciones todos aquellos términos que comienzan con el literal <code>@</code>. En Twitter, se utilizan para hacer referencia a otro usuario en el contenido que se está publicando.</p>
</dd>
<dt class="hdlist1">Hashtags</dt>
<dd>
<p>Un hashtag es un término que comienza con el literal <code>#</code> y sirve para categorizar el contenido de un tuit. Un ejemplo claro es durante los partidos de fútbol del Fútbol Club Barcelona, donde los aficionados que se encuentran comentando el partido en Twitter, suelen acompañar cada publicación con el hashtag <code>#fcblive</code> de manera que clasifican manualmente el contenido de su tuit para poder ser agrupado en una misma conversación.</p>
</dd>
<dt class="hdlist1">Bigramas</dt>
<dd>
<p>En este proyecto, hemos considerado como bigramas todas aquellas combinaciones de 2 palabras que se puedan hacer con el contenido de un tuit. Al contrario que en algunos artículos de investigación anteriores donde sólo se consideran términos consecutivos, en este caso hemos realizado todas las combinaciones posibles para cada tuit.</p>
<div class="paragraph">
<p>Algunas consideraciones importantes sobre esto son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se han eliminado todos aquellos bigramas que contienen 2 veces la misma palabra.</p>
</li>
<li>
<p>Se han eliminado todos aquellos bigramas que contienen al menos una palabra vacía.</p>
</li>
<li>
<p>Se han elminado todos aquellos bigramas con términos inferiores a 2 caracteres.</p>
</li>
<li>
<p>Se han ordenado alfabéticamente todos los bigramas de acuerdo a las 2 palabras que contienen, facilitando así el control de bigramas repetidos.</p>
<div class="paragraph">
<p>Un ejemplo del tipo de bigramas que sacaríamos de analizar un tuit en nuestro proyecto sería:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Buenos días vamos a trabajar todo el día</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Que generaría las siguientes combinaciones</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(buenos días), (buenos vamos), (buenos trabajar), (buenos todo), (buenos día), (días vamos), (días trabajar), (días todo), (día días), (trabajar vamos), (todo vamos), (día vamos), (todo trabajar), (día trabajar), (día todo)</pre>
</div>
</div>
<div class="paragraph">
<p>Como se puede observar, la generación de bigramas para cada tuit provoca una explosión de términos que fue necesario controlar (explicado en <a href="#_utilización_de_algoritmos_de_streaming">Utilización de algoritmos de Streaming</a>) para evitar sobrepasar la memoria del sistema.</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Keywords</dt>
<dd>
<p>Las keywords son unigramas formandos, obviamente, por un único término, cuyo resultado se asemeja a realizar una tokenización sobre el tuit pero aplicando reglas que también se utilizaban en la extracción de bigramas (palabra vacía, longitud inferior a 2 caracteres, etc.).</p>
</dd>
<dt class="hdlist1">Keywords en el campo de Localización</dt>
<dd>
<p>Son el resultado de aplicar la extracción anterior sobre el campo de Localización del perfil del usuario.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_sistema_de_filtros">2.2.1. Sistema de filtros</h4>
<div class="paragraph">
<p>Con el objetivo de poder realizar las extracciones de los términos anteriores de forma flexible, se diseñó un pequeño sistema de filtros que ayudara a combinar varios filtros en una misma ejecución. La implementación de este sistema está basada en el patrón de diseño Decorator<span class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</span>, aunque con la diferencia de que en este caso, la extracción de cada filtro se realiza sobre el tuit original y no sobre el resultado de las extracciones de filtros anteriores (una «decoración» incremental no tendría sentido dado el dominio del problema).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/appendixes/extractor-filter.png" alt="Representación del patrón Decorator que ilustra el sistema de filtros">
</div>
<div class="title">Figure 1. Representación del patrón Decorator que ilustra el sistema de filtros</div>
</div>
</div>
<div class="sect3">
<h4 id="_utilización_de_algoritmos_de_streaming">2.2.2. Utilización de algoritmos de Streaming</h4>
<div class="paragraph">
<p>Como se ha visto en secciones anteriores, el proceso de extracción de términos genera una gran cantidad de datos que será necesario gestionar en memoria. Para solucionar este problema, se hizo uso de técnicas propias de los algoritmos de Streaming, los cuales tienen varios puntos en común con el problema actual.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Algoritmos de Streaming</div>
<div class="paragraph">
<p>Se conocen como algoritmos de Streaming aqellos problemas donde la capacidad de memoria o procesamiento es menor a la cantidad de datos que se reciben como entrada. Estos datos, se procesan de uno en uno y una única vez, manteniendo un orden secuencial e incremental que implica que sea necesario conocer el dato anterior para poder procesar correctamente el dato actual.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La solución, por tanto, pasa por controlar el número de elementos que se gestionan en cada momento en memoria por el sistema, y plantear una estrategia que sea capaz de liberar memoria sin el riesgo de perder información que pueda adulterar los resultados. Los pasos seguidos en este proyecto para lidiar con el problema fueron los siguientes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Establecer un número máximo de <em>keys</em> que podrán ser gestionadas por el hash. Este valor deberá ser configurado por el desarrollador en función de las características hardware sobre las que se ejecute el sistema. En las pruebas realizadas en este proyecto, el número máximo de elementos se situó en 500.000.</p>
<div class="paragraph">
<p>Esto también implica que el sistema de generación de puntuaciones LLR podrá trabajar únicamente sobre los <code>n</code> términos que se seleccionen aquí.</p>
</div>
</li>
<li>
<p>Una vez determinado el umbral máximo de elementos, será necesario definir que porcentaje de términos se eliminarán una vez alcanzado el límite anterior. En este caso, se ha optado por seguir una estrategia de poda agresiva en la que se eliminan de manera constante un % de los elementos con menos frecuencia del hash.</p>
<div class="paragraph">
<p>Esta estrategia implica que siempre que se produzca una situación de poda, se deba ordenar el hash de acuerdo a la frecuencia de sus elementos. De manera experimental, se ha comprobado como la eliminación constante de un 40% de los elementos con menor frecuencia, a pesar de parecer demasiado agresiva, da resultados muy positivos sin existir riesgo de eliminar términos con una frecuencia muy elevada (por supuesto, todo esto dentro del dominio del problema actual).</p>
</div>
</li>
<li>
<p>En el momento de realizar la poda, se debe guardar qué frecuencia es la mayor del grupo de elementos a eliminar. De esta manera, se consigue que términos que vuelvan a aparecer tras la poda, partan de su frecuencia original en vez de volver a empezar de 0. Esto provoca también que muchos términos nuevos, empiecen con una frecuencia más elevada de lo esperado. Sin embargo, la frecuencia mínima que se utilizará después para seleccionar sobre qué términos se aplica el LLR, será lo suficientemente elevada como para evitar situaciones donde este problema pueda adulterar los resultados.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En <a href="#_pseudocódigo_para_ilustrar_el_proceso_completo_de_análisis_de_tuits">Pseudocódigo para ilustrar el proceso completo de análisis de tuits</a> se muestra el proceso para realizar la poda en el algoritmo para extraer la frecuencia de cada término, a través de los métodos <code>check_memory_status</code> y <code>reduce_map_load</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pseudocódigo_para_ilustrar_el_proceso_completo_de_análisis_de_tuits">2.3. Pseudocódigo para ilustrar el proceso completo de análisis de tuits</h3>
<div class="paragraph">
<p>Los siguientes fragmentos de <em>pseudocódigo</em> muestran los diferentes algoritmos que se han utilizado para obtener la frecuencia de términos en los diferentes datasets, así como el proceso para realizar el cálculo de su Log Likelihood-Ratio asociado y la manera de computar la puntuación total de cada tuit en función de la puntuación de cada uno de los términos que contiene.</p>
</div>
<div class="listingblock">
<div class="title">Algoritmo para extraer la frecuencia de cada término</div>
<div class="content">
<pre>for each tweet in tweets do
  terms = apply_extractor_filter(tweet)
  check_memory_status()
  for each term in terms do
    if frequencies[term].is_defined then
      frequencies[term] += 1
    else
      frequencies[term] = minimum_frequency
    end
  end
end

def check_memory_status
  if frequencies.size &gt;= MAXIMUM_EXTRACTED_TERMS then
    reduce_map_load()
  end
end

def reduce_map_load
  items_to_remove   = frequencies.size * FACTOR_TO_REMOVE
  ordered_map       = frequencies.order_by_frequency
  minimum_frequency = ordered_map.get(items_to_remove - 1)

  ordered_map.slice from items_to_remove - 1 to ordered_map.size
end</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Algoritmo para calcular la puntuación LLR de cada término</div>
<div class="content">
<pre>for each term in locals do
  freq = locals[term]
  if freq &gt; min_frequency then
    global_freq = get_global_freq(term)
    if global_freq &gt; 0 then
      k11 = freq
      k12 = global_freq
      k21 = total_local_frequencies
      k22 = total_global_frequencies
      llr = Dunning.normalized_llr(k11, k12, k21, k22)
      results[term] =&gt; llr
    end
  end
end

def get_global_freq(term)
  globals[term].is_defined ? globals[term] : avg_global_freq(term)
end

def avg_global_freq(term)
  same_freq_in_local = locals.select(
    t =&gt; globals[t].is_defined &amp;&amp; locals[t] == locals[term]
  )
  acc = same_freq_in_local.map(t =&gt; globals[t]).reduce(
    (previous, current) =&gt; previous + current
  )
  return acc / same_freq_in_local.size
end</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Algoritmo para calcular la puntuación LLR de cada tuit</div>
<div class="content">
<pre>for each tweet in tweets do
  terms = extract_terms(tweet)
  score = terms.reduce(
    (previous, current) =&gt; previous + get_llr_score(current)
  )
  results[tweet] = score
end</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_experimentos_y_resultados">3. Experimentos y resultados</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_conclusiones_del_sistema_de_geolocalización">4. Conclusiones del sistema de geolocalización</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_aplicación_web_de_geolocalización_como_servicio">5. Aplicación web de geolocalización como servicio</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_análisis_del_sistema">5.1. Análisis del sistema</h3>
<div class="sect3">
<h4 id="_diseño_de_em_mockups_em_para_interfaces_de_usuario">5.1.1. Diseño de <em>mockups</em> para interfaces de usuario</h4>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/application/mockup/home.png" alt="home">
</div>
<div class="title">Figure 2. Pantalla de login de la aplicación.</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/application/mockup/dashboard-projects.png" alt="dashboard projects">
</div>
<div class="title">Figure 3. Pantalla que muestra el dashboard del usuario en la sección de proyectos.</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/application/mockup/dashboard-executions.png" alt="dashboard executions">
</div>
<div class="title">Figure 4. Pantalla que muestra el dashboard del usuario en la sección de ejecuciones.</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/application/mockup/new-project.png" alt="new project" height="650px">
</div>
<div class="title">Figure 5. Lightboxes de creación de un nuevo proyecto.</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/application/mockup/execution.png" alt="execution">
</div>
<div class="title">Figure 6. Pantalla de ejecución de un proyecto en tiempo real.</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_scala">Appendix A: Scala</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_sbt">sbt</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_software_de_aprendizaje_automático_y_vowpal_wabbit">Appendix B: Software de aprendizaje automático y Vowpal Wabbit</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_software_de_aprendizaje_automático">Software de aprendizaje automático</h3>

</div>
<div class="sect2">
<h3 id="_vowpal_wabbit">Vowpal Wabbit</h3>
<div class="paragraph">
<p><strong>Vowpal Wabbit</strong> <span class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote.">4</a>]</span> es un proyecto creado originalmente por <em>Yahoo! Research</em> que fue posteriormente continuado por <em>Microsoft Research</em>, consistente en la creación de un nuevo algoritmo de aprendizaje automático rápido y escalable que permita trabajar con grandes cantidades de datos. A partir de una serie de información específicamente preparada para ser consumida por Vowpal Wabbit, este es capaz de crear un propio modelo de datos que sirva como base de entrenamiento para después, mediante la aplicación de diversos algoritmos, predecir un resultado en base al conocimiento adquirido en ejecuciones anteriores.</p>
</div>
<div class="paragraph">
<p>Además de la velocidad y precisión de los resultados que puede ofrecer Vowpal Wabbit, una de sus características más importantes es la capacidad de funcionar como un demonio del sistema e ir aprendiendo <em>en caliente</em> a través de nuevos modelos de datos. Esto, a diferencia de otros software de aprendizaje automático, permite que el sistema pueda adquirir un conocimiento incremental y ofrecer mejores resultados a medida que pasa el tiempo.</p>
</div>
<div class="sect3">
<h4 id="_normalización_de_datos">Normalización de datos</h4>
<div class="paragraph">
<p>Para aprovechar toda la potencia y velocidad que ofrece Vowpal Wabbit, es necesario generar ficheros de entrada que estén estructurados de acuerdo a un formato optimizado para el clasificador. En este caso, Vowpal Wabbit espera datos de entrada estructurados de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Label] [Importance [Tag]]|Namespace Features |Namespace Features ... |Namespace Features <b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><a href="https://github.com/JohnLangford/vowpal_wabbit/wiki/Input-format">https://github.com/JohnLangford/vowpal_wabbit/wiki/Input-format</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En el presente proyecto, esta estructura generaría datos de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 |Tweet @adrianzenb scl rainer wirth óscar amigos radio quillota
0 |Tweet @thomasuribe medellín colombia celebra día hombre
1 |Tweet @fvminajx @cursiperono mujer ruega punto</pre>
</div>
</div>
<div class="paragraph">
<p>Debido a que un primer momento se consideró la opción de trabajar con modelos multiclase, el sistema que realiza la traducción entre los ficheros de puntuación generados por el sistema Puma y los datos que espera recibir Vowpal Wabbit, debía de ser parametrizable para poder cubrir los siguientes dos casos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Entrenar un modelo de clasificación binario donde sólo se indicara si un tuit pertenece o no a un conjunto de coordenadas (útil para modelos en los que se quiera conocer de manera binaria si una dato pertenece o no a una localización en concreto).</p>
</li>
<li>
<p>Entrenar un modelo de clasificación multiclase donde se agruparan las clases en torno a un número de decimales para la latitud y longitud. Esto haría que se considerasen de la misma clase todos los tuits cuyas coordenadas con 3 decimales sean las mismas, permitiendo obtener predicciones con un grado de precisión de 10 kilómetros (en caso de agrupar por 2 decimales, la precisión sería de 100 y con 1, de 1000 kilómetros).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Para ello, se creo un sistema que mediante una interfaz de línea de comandos pudiese ser configurable mediante los siguientes argumentos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>vw-input-translator 1.0
Usage: vw-input-translator [options] &lt;file&gt;

  --inout
        Flag for creating an input file for binary classification
  -d &lt;value&gt; | --decimals &lt;value&gt;
        Creates an input file for multi-class classification. Each sample will have the selected number of decimals on latitude and longitude coordinates
  &lt;file&gt;
        Source file</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_división_de_datos_en_conjuntos_de_entrenamiento_y_test">División de datos en conjuntos de entrenamiento y test</h4>
<div class="paragraph">
<p>Con el objetivo de entrenar al clasificador, se desarrolló un script capaz de, a partir de los datos de entrada que recibiría Vowpal Wabbit, dividir el conjunto en dos para dedicar una parte al proceso de entrenamiento y otra a probar el modelo de datos generados.</p>
</div>
<div class="paragraph">
<p>Con el objetivo de generar dos conjuntos consistentes, la división se realizó en base a los usuarios, haciendo que un mismo usuario no pudiese formar parte de ambos grupos. Un 80% de los usuarios sería destinado al grupo de entrenamiento, mientras que el 20% restante iría a parar al conjunto de test.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_falcon_sistema_para_coleccionar_datos_de_la_api_streaming_de_twitter">Appendix C: Falcon, sistema para coleccionar datos de la API Streaming de Twitter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para crear los diferentes datasets que fueron necesarios para desarrollar los prototipos y modelos de datos, se diseñó un sistema capaz de conectarse a la <strong>API Streaming de Twitter</strong> (<a href="https://dev.twitter.com/docs/api/streaming">https://dev.twitter.com/docs/api/streaming</a>) para descargar y almacenar tuits en tiempo real.</p>
</div>
<div class="paragraph">
<p>Este sistema debía ser parametrizable, con el objetivo de poder configurar en cada ejecución el tipo de tuits que se querían obtener de acuerdo a los filtros disponibles a través de la API de Twitter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Filtro por idioma del tuit</p>
</li>
<li>
<p>Filtro por localización del tuit (mediante el uso de <em>bounding boxes</em>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para realizar la conexión entre el sistem Falcon y la API de Twitter se utilizó la biblioteca <strong>Twitter4j</strong> (<a href="http://twitter4j.org/en/index.html">http://twitter4j.org/en/index.html</a>). La ventajas de utilizar una biblioteca construida sobre la API original es que algunos de los problemas más habituales se solucionan a través de nuevas capas de abstracción:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Autenticación OAuth2 simplificada mediante clases propias de la biblioteca</p>
</li>
<li>
<p>Simplificación del proceso para poder utilizar la API de Streaming, aislando al desarrollador de la complejidad para mantener activa la conexión con el servidor de Twitter.</p>
</li>
</ol>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/appendixes/twitter-streaming-api.png" alt="Modelo de comunicación entre un cliente y la API Streaming de Twitter">
</div>
<div class="title">Figure 7. Comunicación entre un cliente y la API Streaming de Twitter<span class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnote_5" title="View footnote.">5</a>]</span></div>
</div>
<div class="sect2">
<h3 id="_almacenamiento_de_datos">Almacenamiento de datos</h3>
<div class="paragraph">
<p>Uno de los puntos más importantes que planteó el sistema para recolectar tuits era en qué formato sería más adecuado serializar los datos obtenidos.</p>
</div>
<div class="paragraph">
<p>En un primer momento se barajó la posibilidad de utilizar el formato CSV, el cual permitiría acceder de manera rápida al número de tuits guardados y realizar operaciones sencillas en línea de comandos mediante operaciones <code>grep</code>. Esta decisión fue descartada al realizar los primeros experimentos y comprobar como el guardado de ciertos datos en formato CSV presenta muchas dificultades para poder solventar todos los casos esquina que se presentan con la aparición de contenido complejo que pueda incluir comas, comillas y otros signos de puntuación (aún en el caso de utilizar bibliotecas especializadas como OpenCSV - <a href="http://opencsv.sourceforge.net/">http://opencsv.sourceforge.net/</a> ) combinados con caracteres extraños como Emoji (<a href="http://www.unicode.org/faq/emoji_dingbats.html">http://www.unicode.org/faq/emoji_dingbats.html</a>).</p>
</div>
<div class="paragraph">
<p>Como consecuencia de los resultados anteriores, y apoyado en el soporte nativo ofrecido por Scala, se utilizó XML como el lenguaje de estructuración de datos que mejor podría serializar la información obtenida a través de Twitter4j. El siguiente fragmento de código permite ver lo sencillo que es serializar un objeto en Scala a XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="scala language-scala">class Tweet(id:String, username: String, name:String, location: String, timezone: String, createdAt:String, latitude: String, longitude: String, text: String) {
  def toXML =
    &lt;tweet&gt;
      &lt;id&gt;
        {id}
      &lt;/id&gt;
      &lt;username&gt;
        {username}
      &lt;/username&gt;
      &lt;name&gt;
        {name}
      &lt;/name&gt;
      &lt;location&gt;
        {location}
      &lt;/location&gt;
      &lt;timezone&gt;
        {timezone}
      &lt;/timezone&gt;
      &lt;createdAt&gt;
        {createdAt}
      &lt;/createdAt&gt;
      &lt;latitude&gt;
        {latitude}
      &lt;/latitude&gt;
      &lt;longitude&gt;
        {longitude}
      &lt;/longitude&gt;
      &lt;text&gt;
        {text}
      &lt;/text&gt;
    &lt;/tweet&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parámetros_del_sistema">Parámetros del sistema</h3>
<div class="paragraph">
<p>Debido a que Falcon es un sistema sin ánimo de ejecutarse a través de una GUI, la manera de parametrizar la ejecución ha sido a través de una interfaz de línea de comandos. Para ello, se ha utilizado la biblioteca <strong>scopt</strong> (<a href="https://github.com/scopt/scopt">https://github.com/scopt/scopt</a>).</p>
</div>
<div class="paragraph">
<p>scopt permite parsear de manera sencilla los argumentos que se le pasan al programa en el momento de su ejecución. Para ello, simplemente hay que definir un objeto <code>ScoptParser</code> que contenga las reglas necesarias para especificar qué parámetros se esperan, qué tipo deben tener (<code>String</code>, <code>Integer</code>, <code>Boolean</code>, etc.) y si son requeridos u opcionales.</p>
</div>
<div class="paragraph">
<p>A continuación se muestra el mensaje de ayuda de la aplicación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Falcon 1.0
Usage: Falcon [options]

  -l &lt;value&gt; | --language &lt;value&gt;
        Specifies the language, in ISO 639-1 format, for the tweets to collect.
  -k &lt;value&gt; | --keywords &lt;value&gt;
        Specifies the file for the keywords.
  -t &lt;value&gt; | --time-in &lt;value&gt;
        The time measure for collecting tweets (SECONDS, MINUTES, HOURS, DAYS).
  -n &lt;value&gt; | --timestamp &lt;value&gt;
        Units of time for collecting tweets.
  -o &lt;value&gt; | --output &lt;value&gt;
        The output filename where store the collection results.
  -c &lt;value&gt; | --credentials &lt;value&gt;
        Properties file with the Twitter credentials
  -b &lt;value&gt; | --bounding-boxes &lt;value&gt;
        Specifies the file which contains the bounding boxes.</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>--time-in</code> y <code>--timestamp</code>: permiten establecer al recolector un tiempo de ejecución representado en diferentes magnitudes.</p>
</li>
<li>
<p><code>--output</code>: nombre del fichero de salida.</p>
</li>
<li>
<p><code>--language</code>: idioma en el que se desean obtener los tuits.</p>
</li>
<li>
<p><code>--stopwords</code>: debido a restricciones de Twitter, es necesario proveer una lista de términos cuando se intenta realizar un filtrado por idioma. Con el objetivo de restringir lo mínimo posible el número de tuits a obtener, se provee una lista de <em>stop words</em> del idioma por el que se esté filtrando.</p>
</li>
<li>
<p><code>--bounding-boxes</code>: fichero <code>XML</code> que contiene los <em>bounding boxes</em> sobre los que se realizará el filtrado.</p>
</li>
<li>
<p><code>--credentials</code>: indica el fichero que contiene las credenciales que se utilizarán para conectarse con la API de Twitter y utilizar su servicio de Streaming.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un ejemplo de uso para obtener datos en español sobre los bounding boxes de España durante un día, podría ser algo como esto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>falcon.jar -l es -s es_stop_words.txt -t DAYS -n 1 -o es_tweets_collection -c credentials.properties -b spain_bounding_boxes.xml</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplo_de_resultados">Ejemplo de resultados</h3>
<div class="paragraph">
<p>Un ejemplo de los resultados obtenidos por el recolector sería el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="xml language-xml">&lt;tweet&gt;
  &lt;id&gt;
    469499350327255040
  &lt;/id&gt;
  &lt;username&gt;
    jessfhickey
  &lt;/username&gt;
  &lt;name&gt;
    Jessica Hickey
  &lt;/name&gt;
  &lt;location&gt;
    Ireland
  &lt;/location&gt;
  &lt;timezone&gt;
    London
  &lt;/timezone&gt;
  &lt;createdAt&gt;
    2014-05-22 15:25
  &lt;/createdAt&gt;
  &lt;latitude&gt;
    53.3444086
  &lt;/latitude&gt;
  &lt;longitude&gt;
    -6.2649497
  &lt;/longitude&gt;
  &lt;text&gt;
    In the most beautiful cafe ever. #boulevardcafe
  &lt;/text&gt;
&lt;/tweet&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_b2pick_aplicación_web_para_seleccionar_em_bounding_boxes_em">Appendix D: B2pick, aplicación web para seleccionar <em>bounding boxes</em></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Uno de los procesos más habituales durante el desarrollo del proyecto fue la selección de bounding boxes para aplicar filtros sobre el Streaming de Twitter. Un bounding box, se puede definir como un rectángulo que abarca un área geográfica en concreto que queda definida por sus coordenadas suroeste y noreste.</p>
</div>
<div class="paragraph">
<p><strong>B2pick</strong> (<a href="https://github.com/sergio-alvarez/b2pick">https://github.com/sergio-alvarez/b2pick</a>), viene a cubrir la necesidad de poder automatizar el proceso mediante una sencilla aplicación web escrita puramente en JavaScript en la capa de cliente, que mediante la utilización de la API de Google Maps permita dibujar al usuario rectángulos sobre las zonas geográficas que desee.</p>
</div>
<div class="paragraph">
<p>Actualmente, no se conoce ninguna herramienta que ofrezca un servicio similar.</p>
</div>
<div class="paragraph">
<p>Una vez el usuario ha seleccionado los bounding boxes que desea, B2pick ofrece la posibilidad de descargarlos en formato XML (que es el formato que se ha utilizado a la hora de desarrollar los prototipos), siendo posible en el futuro adaptar fácilmente el formato de salida a otros también populares como JSON o CSV.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de salida XML para un conjunto de Bounding Boxes</div>
<div class="content">
<pre class="highlight"><code class="xml language-xml">&lt;boundingBoxes&gt;
  &lt;boundingBox&gt;
    &lt;sw&gt;
      &lt;latitude&gt;35.75&lt;/latitude&gt;
      &lt;longitude&gt;-12.04&lt;/longitude&gt;
    &lt;/sw&gt;
    &lt;ne&gt;
      &lt;latitude&gt;44.53&lt;/latitude&gt;
      &lt;longitude&gt;4.22&lt;/longitude&gt;
    &lt;/ne&gt;
  &lt;/boundingBox&gt;
  &lt;boundingBox&gt;
    &lt;sw&gt;
      &lt;latitude&gt;50.23&lt;/latitude&gt;
      &lt;longitude&gt;-13.89&lt;/longitude&gt;
    &lt;/sw&gt;
    &lt;ne&gt;
      &lt;latitude&gt;59.27&lt;/latitude&gt;
      &lt;longitude&gt;1.85&lt;/longitude&gt;
    &lt;/ne&gt;
  &lt;/boundingBox&gt;
  &lt;boundingBox&gt;
    &lt;sw&gt;
      &lt;latitude&gt;54.72&lt;/latitude&gt;
      &lt;longitude&gt;6.24&lt;/longitude&gt;
    &lt;/sw&gt;
    &lt;ne&gt;
      &lt;latitude&gt;57.61&lt;/latitude&gt;
      &lt;longitude&gt;12.83&lt;/longitude&gt;
    &lt;/ne&gt;
  &lt;/boundingBox&gt;
&lt;/boundingBoxes&gt;</code></pre>
</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/appendixes/b2pick-main-screen.png" alt="Imagen de la pantalla principal de b2pick">
</div>
<div class="title">Figure 8. Imagen de la pantalla principal de B2pick</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../assets/appendixes/b2pick-lightbox.png" alt="Ejemplo del lightbox de salida con los bounding boxes seleccionados">
</div>
<div class="title">Figure 9. Ejemplo del lightbox de salida con los bounding boxes seleccionados</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tweetheat_mapa_de_calor_sobre_ficheros_tsv_de_puntuación">Appendix E: TweetHeat, mapa de calor sobre ficheros TSV de puntuación</h2>
<div class="sectionbody">

</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. Conjunto de nombres geográficos que, junto con un mapa, constituye una importante referencia sobre lugares y sus nombres
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. Disponible en: <a href="http://aisl.umbc.edu/resources/369.pdf">http://aisl.umbc.edu/resources/369.pdf</a> (ver tablas y ecuaciones en la página 7)
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. <a href="http://perldesignpatterns.com/?word=decorator+pattern">http://perldesignpatterns.com/?word=decorator+pattern</a>
</div>
<div class="footnote" id="_footnote_4">
<a href="#_footnoteref_4">4</a>. <a href="http://hunch.net/~vw/">http://hunch.net/~vw/</a>
</div>
<div class="footnote" id="_footnote_5">
<a href="#_footnoteref_5">5</a>. <a href="https://dev.twitter.com/docs/api/streaming">https://dev.twitter.com/docs/api/streaming</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2014-05-31 18:30:31 CEST
</div>
</div>
</body>
</html>